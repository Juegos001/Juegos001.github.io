<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxy Overdrive</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', 'Arial', sans-serif;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            cursor: crosshair;
        }
        
        #game-canvas {
            display: block;
            background: #0a0a1a;
        }
        
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(10, 10, 30, 0.8);
            color: white;
            z-index: 10;
            backdrop-filter: blur(5px);
        }
        
        #game-over-screen { display: none; }
        
        h1 {
            font-size: 4rem;
            margin-bottom: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 5px;
            color: #ff4757;
            text-shadow: 0 0 15px #ff4757, 0 0 25px #ff4757;
            animation: flicker 1.5s infinite alternate;
        }

        @keyframes flicker {
            0%, 18%, 22%, 25%, 53%, 57%, 100% {
                text-shadow:
                0 0 10px #ff4757,
                0 0 20px #ff4757,
                0 0 30px #ff4757,
                0 0 40px #ff4757;
            }
            20%, 24%, 55% { text-shadow: none; }
        }
        
        button {
            background: linear-gradient(135deg, #ff4757 0%, #ff6b81 100%);
            border: 2px solid #ff8c9a;
            color: white;
            padding: 1rem 2.5rem;
            font-size: 1.3rem;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 2rem;
            box-shadow: 0 5px 20px rgba(255, 71, 87, 0.5);
            transition: all 0.3s ease;
            text-transform: uppercase;
        }
        
        button:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 30px rgba(255, 71, 87, 0.7);
        }

        #ui-container {
            position: absolute; top: 20px; left: 20px;
            color: white; z-index: 5; text-shadow: 0 0 5px black;
        }
        #score-display { font-size: 1.8rem; font-weight: bold; }
        #health-bar {
            width: 250px; height: 25px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 15px; overflow: hidden; margin-top: 10px;
        }
        #health-fill {
            height: 100%; width: 100%;
            background: linear-gradient(90deg, #32ff7e, #1dd1a1);
            transition: width 0.3s ease, background 0.5s ease;
        }

        #ability-ui {
            position: absolute; bottom: 30px; left: 50%;
            transform: translateX(-50%);
            display: flex; gap: 20px;
            z-index: 5;
        }
        .ability {
            width: 60px; height: 60px;
            background: rgba(10, 10, 30, 0.7);
            border: 2px solid #4ecdc4;
            border-radius: 50%;
            position: relative;
            color: white;
            font-size: 0.8rem;
            text-align: center;
            padding-top: 40px;
        }
        .ability::before {
             content: '';
             font-weight: bold;
             font-size: 1.2rem;
             position: absolute;
             top: 10px; left: 50%;
             transform: translateX(-50%);
        }
        #dash-ability::before { content: 'DASH'; }
        #bomb-ability::before { content: 'BOMB'; }
        .cooldown-overlay {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 50%;
            transform: scaleY(0);
            transform-origin: bottom;
            transition: transform 0.1s linear;
        }

        #wave-announcement {
            position: absolute;
            top: 25%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem; color: white;
            text-shadow: 0 0 15px #ff9f43;
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 11;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        
        <div id="ui-container">
            <div id="score-display">Score: 0</div>
            <div id="health-bar">
                <div id="health-fill"></div>
            </div>
        </div>

        <div id="ability-ui">
            <div id="dash-ability" class="ability">Shift
                <div id="dash-cooldown" class="cooldown-overlay"></div>
            </div>
            <div id="bomb-ability" class="ability">Space
                <div id="bomb-cooldown" class="cooldown-overlay"></div>
            </div>
        </div>

        <div id="wave-announcement"></div>
        
        <div id="start-screen">
            <h1>Galaxy Overdrive</h1>
            <p>WASD: Moverse | Click Izq: Disparar</p>
            <p>Shift / Click Der: Impulso | Espacio: Bomba</p>
            <button id="start-button">Iniciar Vuelo</button>
        </div>
        
        <div id="game-over-screen">
            <h1>Game Over</h1>
            <div class="final-score" style="font-size: 2rem;">Puntuaci√≥n: <span id="final-score">0</span></div>
            <button id="restart-button">Intentar de Nuevo</button>
        </div>
    </div>

    <script>
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    
    // --- UI Elements ---
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const startButton = document.getElementById('start-button');
    const restartButton = document.getElementById('restart-button');
    const scoreDisplay = document.getElementById('score-display');
    const healthFill = document.getElementById('health-fill');
    const finalScoreDisplay = document.getElementById('final-score');
    const dashCooldownUI = document.getElementById('dash-cooldown');
    const bombCooldownUI = document.getElementById('bomb-cooldown');
    const waveAnnouncer = document.getElementById('wave-announcement');

    // --- Game State ---
    let gameRunning = false;
    let score, playerHealth, keys, mouseX, mouseY;
    let player, bullets, enemies, particles, powerups, enemyBullets, boss;
    let screenShake = { intensity: 0, duration: 0, time: 0 };
    let stars = [];

    // --- Game Configuration ---
    const PLAYER_CONFIG = {
        radius: 18, speed: 5, health: 100,
        shootDelay: 150, weaponLevel: 1,
        dashSpeed: 25, dashDuration: 150, dashCooldown: 1500,
        bombCooldown: 10000,
    };

    // --- Web Audio API for Sound ---
    let audioContext;
    const soundBuffers = {};
    function initAudio() {
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            console.warn("Web Audio API is not supported in this browser");
        }
    }
    
    // --- Main Functions ---
    window.addEventListener('resize', resizeCanvas);
    startButton.addEventListener('click', () => { if (!audioContext) initAudio(); startGame(); });
    restartButton.addEventListener('click', startGame);

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    function startGame() {
        resizeCanvas();
        gameRunning = true;
        score = 0;
        keys = {};
        mouseX = canvas.width / 2;
        mouseY = 0;
        
        player = {
            ...PLAYER_CONFIG,
            x: canvas.width / 2, y: canvas.height * 0.8,
            lastShot: 0, direction: { x: 0, y: 0 },
            isDashing: false, dashTimer: 0, lastDash: -PLAYER_CONFIG.dashCooldown,
            lastBomb: -PLAYER_CONFIG.bombCooldown
        };
        
        bullets = []; enemies = []; particles = []; powerups = []; enemyBullets = [];
        boss = null;

        // Dynamic Starfield
        if (stars.length === 0) {
            for (let i = 0; i < 200; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 1.5,
                    speed: 0.1 + Math.random() * 0.4
                });
            }
        }
        
        WaveSystem.init();
        updateUI();

        startScreen.style.display = 'none';
        gameOverScreen.style.display = 'none';
        
        gameLoop();
    }
    
    let lastTime = 0;
    function gameLoop(timestamp) {
        if (!gameRunning) return;
        const deltaTime = (timestamp - lastTime) || 16.67;
        lastTime = timestamp;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // --- Screen Shake ---
        ctx.save();
        if (screenShake.time > 0) {
            screenShake.time -= deltaTime;
            const dx = (Math.random() - 0.5) * screenShake.intensity;
            const dy = (Math.random() - 0.5) * screenShake.intensity;
            ctx.translate(dx, dy);
        }

        // --- Drawing ---
        drawBackground();
        
        // Player is drawn on top of most things
        updatePlayer(deltaTime);
        if (!player.isDashing || Math.floor(player.dashTimer / 20) % 2 === 0) {
            drawPlayer();
        }
        
        updateAndDraw(bullets, deltaTime);
        updateAndDraw(enemyBullets, deltaTime);
        updateAndDraw(enemies, deltaTime);
        updateAndDraw(powerups, deltaTime);
        updateAndDraw(particles, deltaTime);

        if (boss) {
            boss.update(deltaTime);
            boss.draw();
        }

        // --- Game Logic ---
        handleCollisions();
        WaveSystem.update(deltaTime);

        ctx.restore(); // Restore from screen shake
        updateUI();

        if (player.health <= 0) {
            gameOver();
        } else {
            requestAnimationFrame(gameLoop);
        }
    }
    
    function gameOver() {
        gameRunning = false;
        createExplosion(player.x, player.y, player.radius * 5, 50);
        triggerScreenShake(20, 500);
        // Sonido: gameOver
        setTimeout(() => {
            finalScoreDisplay.textContent = score;
            gameOverScreen.style.display = 'flex';
        }, 1000);
    }
    
    // --- Update & Draw Helpers ---
    function updateAndDraw(arr, deltaTime) {
        for (let i = arr.length - 1; i >= 0; i--) {
            arr[i].update(deltaTime);
            arr[i].draw();
            if (arr[i].isOffscreen || arr[i].life <= 0) {
                arr.splice(i, 1);
            }
        }
    }

    function drawBackground() {
        ctx.fillStyle = '#0a0a1a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        stars.forEach(star => {
            star.y += star.speed;
            if (star.y > canvas.height) {
                star.y = 0;
                star.x = Math.random() * canvas.width;
            }
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fill();
        });
    }

    // --- Entity Creation ---
    function createExplosion(x, y, baseSize, numParticles) {
        for (let i = 0; i < numParticles; i++) {
            particles.push(new Particle({
                x, y,
                radius: Math.random() * baseSize / 5 + 1,
                speed: Math.random() * 5 + 1,
                life: Math.random() * 500 + 200,
                color: ['#ff9f43', '#ff6b6b', '#ff4757', '#ffa502'][Math.floor(Math.random()*4)]
            }));
        }
        triggerScreenShake(baseSize/5, 200);
        // Sonido: explosion
    }
    
    // --- Player Logic ---
    function updatePlayer(deltaTime) {
        // --- Movement ---
        player.direction = { x: 0, y: 0 };
        if (keys['w']) player.direction.y = -1;
        if (keys['s']) player.direction.y = 1;
        if (keys['a']) player.direction.x = -1;
        if (keys['d']) player.direction.x = 1;
        const len = Math.sqrt(player.direction.x**2 + player.direction.y**2);
        if (len > 0) {
            player.x += player.direction.x / len * player.speed;
            player.y += player.direction.y / len * player.speed;
        }

        // --- Dashing ---
        if (player.isDashing) {
            player.dashTimer -= deltaTime;
            player.x += player.dashDirection.x * player.dashSpeed;
            player.y += player.dashDirection.y * player.dashSpeed;
            // Create after-image particles
             particles.push(new Particle({
                x: player.x, y: player.y, radius: player.radius, life: 200, 
                color: 'rgba(78, 220, 196, 0.5)', fade: true
            }));
            if (player.dashTimer <= 0) player.isDashing = false;
        }

        // --- Boundaries ---
        player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
        player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));

        // --- Thruster Particles ---
        if (len > 0 && !player.isDashing) {
            const angle = Math.atan2(player.direction.y, player.direction.x) + Math.PI;
            for(let i=0; i<2; i++){
                particles.push(new Particle({
                    x: player.x, y: player.y,
                    radius: Math.random() * 3 + 1,
                    speed: Math.random() * 2 + 1,
                    life: 200,
                    angle: angle + (Math.random() - 0.5) * 0.5,
                    color: ['#ff9f43', '#ff6b6b'][Math.floor(Math.random()*2)]
                }));
            }
        }
    }

    function drawPlayer() {
        const angle = Math.atan2(mouseY - player.y, mouseX - player.x);
        ctx.save();
        ctx.translate(player.x, player.y);
        ctx.rotate(angle);
        ctx.fillStyle = player.isDashing ? '#4ecdc4' : '#ffffff';
        ctx.strokeStyle = '#4ecdc4';
        ctx.lineWidth = 3;
        
        ctx.beginPath();
        ctx.moveTo(player.radius, 0); // Nose
        ctx.lineTo(-player.radius * 0.8, -player.radius * 0.8); // Top Wing
        ctx.lineTo(-player.radius * 0.5, 0); // Center back
        ctx.lineTo(-player.radius * 0.8, player.radius * 0.8); // Bottom Wing
        ctx.closePath();
        
        ctx.fill();
        ctx.stroke();
        ctx.restore();
    }
    
    function shoot(e) {
        if (!gameRunning || e.button !== 0) return;
        const now = Date.now();
        if (now - player.lastShot < player.shootDelay) return;
        player.lastShot = now;

        const dx = mouseX - player.x;
        const dy = mouseY - player.y;
        const angle = Math.atan2(dy, dx);
        
        const bulletConfig = {
            x: player.x + Math.cos(angle) * player.radius,
            y: player.y + Math.sin(angle) * player.radius,
            direction: {x: Math.cos(angle), y: Math.sin(angle)},
        };

        if (player.weaponLevel === 1) {
            bullets.push(new Bullet(bulletConfig));
        } else if (player.weaponLevel === 2) {
            bullets.push(new Bullet({...bulletConfig, x: bulletConfig.x - Math.sin(angle) * 8, y: bulletConfig.y + Math.cos(angle) * 8}));
            bullets.push(new Bullet({...bulletConfig, x: bulletConfig.x + Math.sin(angle) * 8, y: bulletConfig.y - Math.cos(angle) * 8}));
        } else { // Level 3+
            bullets.push(new Bullet(bulletConfig));
            const spreadAngle = 0.2;
            bullets.push(new Bullet({
                ...bulletConfig,
                direction: {x: Math.cos(angle - spreadAngle), y: Math.sin(angle - spreadAngle)}
            }));
            bullets.push(new Bullet({
                ...bulletConfig,
                direction: {x: Math.cos(angle + spreadAngle), y: Math.sin(angle + spreadAngle)}
            }));
        }
        // Sonido: shoot
    }

    function useDash() {
        const now = Date.now();
        if (player.isDashing || now - player.lastDash < player.dashCooldown) return;
        player.lastDash = now;
        player.isDashing = true;
        player.dashTimer = player.dashDuration;

        const dx = mouseX - player.x;
        const dy = mouseY - player.y;
        const len = Math.sqrt(dx**2 + dy**2);
        player.dashDirection = len > 0 ? {x: dx/len, y: dy/len} : {x:0, y:-1};
        // Sonido: dash
    }
    
    function useBomb() {
        const now = Date.now();
        if (now - player.lastBomb < player.bombCooldown) return;
        player.lastBomb = now;

        createExplosion(player.x, player.y, canvas.width, 1);
        particles.push(new Shockwave(player.x, player.y));
        triggerScreenShake(30, 800);
        // Sonido: bomb_explosion

        // Damage enemies and clear bullets
        enemies.forEach(e => e.takeDamage(150));
        if(boss) boss.takeDamage(500);
        enemyBullets = [];
    }

    // --- Collisions ---
    function handleCollisions() {
        // Bullets -> Enemies
        for (let i = bullets.length - 1; i >= 0; i--) {
            for (let j = enemies.length - 1; j >= 0; j--) {
                if (checkCollision(bullets[i], enemies[j])) {
                    enemies[j].takeDamage(bullets[i].damage);
                    bullets.splice(i, 1);
                    break;
                }
            }
            if(boss && bullets[i] && checkCollision(bullets[i], boss)) {
                boss.takeDamage(bullets[i].damage);
                bullets.splice(i, 1);
            }
        }
        
        if (player.isDashing) return;

        // Player -> Enemies
        for (let i = enemies.length - 1; i >= 0; i--) {
            if (checkCollision(player, enemies[i])) {
                playerDamage(enemies[i].collisionDamage);
                enemies[i].takeDamage(1000); // Enemy dies on collision
                break;
            }
        }
        if (boss && checkCollision(player, boss)) {
            playerDamage(boss.collisionDamage);
        }

        // Player -> Enemy Bullets
        for (let i = enemyBullets.length - 1; i >= 0; i--) {
            if (checkCollision(player, enemyBullets[i])) {
                playerDamage(enemyBullets[i].damage);
                createExplosion(enemyBullets[i].x, enemyBullets[i].y, 10, 5);
                enemyBullets.splice(i, 1);
                break;
            }
        }

        // Player -> Powerups
        for (let i = powerups.length - 1; i >= 0; i--) {
            if (checkCollision(player, powerups[i])) {
                powerups[i].applyEffect();
                powerups.splice(i, 1);
                break;
            }
        }
    }

    function checkCollision(obj1, obj2) {
        const dx = obj1.x - obj2.x;
        const dy = obj1.y - obj2.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        return dist < obj1.radius + obj2.radius;
    }
    
    function playerDamage(amount) {
        player.health -= amount;
        triggerScreenShake(10, 150);
        // Sonido: player_hit
    }

    // --- UI Update ---
    function updateUI() {
        scoreDisplay.textContent = `Score: ${score}`;
        
        healthFill.style.width = `${Math.max(0, player.health)}%`;
        if (player.health < 30) {
            healthFill.style.background = 'linear-gradient(90deg, #ff6b6b, #ee5253)';
        } else if (player.health < 60) {
            healthFill.style.background = 'linear-gradient(90deg, #feca57, #ff9f43)';
        } else {
            healthFill.style.background = 'linear-gradient(90deg, #1dd1a1, #10ac84)';
        }

        const dashCD = Math.max(0, 1 - (Date.now() - player.lastDash) / player.dashCooldown);
        dashCooldownUI.style.transform = `scaleY(${dashCD})`;
        
        const bombCD = Math.max(0, 1 - (Date.now() - player.lastBomb) / player.bombCooldown);
        bombCooldownUI.style.transform = `scaleY(${bombCD})`;
    }
    
    function triggerScreenShake(intensity, duration) {
        screenShake.intensity = intensity;
        screenShake.duration = duration;
        screenShake.time = duration;
    }

    // --- Input Listeners ---
    document.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if (e.key === ' ' || e.key === 'Spacebar') { e.preventDefault(); useBomb(); } if (e.key === 'Shift') useDash(); });
    document.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });
    canvas.addEventListener('mousemove', e => { const rect = canvas.getBoundingClientRect(); mouseX = e.clientX - rect.left; mouseY = e.clientY - rect.top; });
    canvas.addEventListener('mousedown', e => { if (e.button === 0) shoot(e); else if (e.button === 2) { e.preventDefault(); useDash(); } });
    canvas.addEventListener('contextmenu', e => e.preventDefault());


    // ============================
    // --- CLASSES & SYSTEMS ---
    // ============================
    class Entity {
        constructor({x, y, radius, speed = 0, angle = null, life = Infinity}) {
            this.x = x;
            this.y = y;
            this.radius = radius;
            this.speed = speed;
            this.life = life;
            this.isOffscreen = false;
            
            if(angle !== null){
                this.direction = { x: Math.cos(angle), y: Math.sin(angle) };
            }
        }

        update(deltaTime) {
            if (this.direction) {
                this.x += this.direction.x * this.speed;
                this.y += this.direction.y * this.speed;
            }
            this.life -= deltaTime;
            this.isOffscreen = this.x < -this.radius || this.x > canvas.width + this.radius || this.y < -this.radius || this.y > canvas.height + this.radius;
        }

        draw() { /* To be implemented by subclasses */ }
    }

    class Bullet extends Entity {
        constructor({x, y, direction}) {
            super({x, y, radius: 5, speed: 12});
            this.direction = direction;
            this.damage = 25;
            this.color = '#ffdd59';
        }
        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    class EnemyBullet extends Bullet {
        constructor({x, y, direction}) {
            super({x, y, direction});
            this.speed = 5;
            this.damage = 10;
            this.radius = 6;
            this.color = '#ff6b81';
        }
    }

    class Particle extends Entity {
        constructor({x, y, radius, speed, life, color, angle = Math.random() * Math.PI * 2, fade = false}) {
            super({x, y, radius, speed, angle, life});
            this.color = color;
            this.initialLife = life;
            this.fade = fade;
        }
        draw() {
            ctx.save();
            ctx.globalAlpha = this.fade ? this.life / this.initialLife : 1;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    }

    class Shockwave extends Entity {
        constructor(x, y) {
            super({x, y, radius: 20, life: 500});
        }
        update(deltaTime) {
            super.update(deltaTime);
            this.radius += 4;
        }
        draw() {
            ctx.save();
            ctx.globalAlpha = this.life / 500;
            ctx.strokeStyle = `rgba(255, 255, 255, ${this.life / 500})`;
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
    }
    
    class Enemy extends Entity {
        constructor({x, y, radius, speed, health, color, scoreValue, type}) {
            super({x, y, radius, speed});
            this.health = health;
            this.maxHealth = health;
            this.color = color;
            this.scoreValue = scoreValue;
            this.type = type;
            this.collisionDamage = 20;
            this.hitTimer = 0;
        }
        update(deltaTime) {
            // Movement towards player
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist > 0) {
                this.x += dx / dist * this.speed;
                this.y += dy / dist * this.speed;
            }
            if (this.hitTimer > 0) this.hitTimer -= deltaTime;
        }

        draw() {
            const drawColor = this.hitTimer > 0 ? '#ffffff' : this.color;
            ctx.fillStyle = drawColor;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }

        takeDamage(amount) {
            this.health -= amount;
            this.hitTimer = 100;
            // Sonido: enemy_hit
            if (this.health <= 0) {
                this.die();
            }
        }
        die() {
            score += this.scoreValue;
            this.life = 0; // Mark for removal
            createExplosion(this.x, this.y, this.radius * 2, 20);
            
            // Powerup drop chance
            if (Math.random() < 0.15) { // 15% chance
                const type = Math.random() < 0.7 ? 'health' : 'weapon';
                powerups.push(new PowerUp(this.x, this.y, type));
            }
        }
    }

    class GunnerEnemy extends Enemy {
        constructor({x, y}) {
            super({x, y, radius: 20, speed: 1.5, health: 80, color: '#ff9f43', scoreValue: 50, type: 'gunner'});
            this.lastShot = Date.now();
            this.shootDelay = 2000;
        }
        update(deltaTime) {
            const distToPlayer = Math.sqrt((player.x - this.x)**2 + (player.y - this.y)**2);
            if (distToPlayer > 300) { // Move closer if far away
                super.update(deltaTime);
            }

            if (Date.now() - this.lastShot > this.shootDelay) {
                this.lastShot = Date.now();
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                enemyBullets.push(new EnemyBullet({x:this.x, y:this.y, direction: {x:Math.cos(angle), y:Math.sin(angle)}}));
                // Sonido: enemy_shoot
            }
            if (this.hitTimer > 0) this.hitTimer -= deltaTime;
        }
        draw() { // Triangle shape
            const drawColor = this.hitTimer > 0 ? '#ffffff' : this.color;
            ctx.fillStyle = drawColor;
            ctx.save();
            ctx.translate(this.x, this.y);
            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.moveTo(this.radius, 0);
            ctx.lineTo(-this.radius, -this.radius * 0.8);
            ctx.lineTo(-this.radius, this.radius * 0.8);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }
    }
    
    class PowerUp extends Entity {
        constructor(x, y, type) {
            super({x, y, radius: 12, life: 10000});
            this.type = type;
            this.color = type === 'health' ? '#1dd1a1' : '#ffdd59';
            this.pulseTimer = 0;
        }
        update(deltaTime) {
            super.update(deltaTime);
            this.pulseTimer += deltaTime / 1000;
        }
        draw() {
            const scale = 1 + Math.sin(this.pulseTimer * 5) * 0.1;
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.scale(scale, scale);
            ctx.fillStyle = this.color;
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.beginPath();
            if (this.type === 'health') {
                ctx.fillRect(-this.radius / 2, -this.radius/6, this.radius, this.radius/3);
                ctx.fillRect(-this.radius / 6, -this.radius/2, this.radius/3, this.radius);
            } else { // weapon
                ctx.arc(0, 0, this.radius * 0.8, 0, Math.PI * 2);
            }
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }
        applyEffect() {
            if (this.type === 'health') {
                player.health = Math.min(PLAYER_CONFIG.health, player.health + 25);
                // Sonido: powerup_health
            } else {
                player.weaponLevel = Math.min(3, player.weaponLevel + 1);
                // Sonido: powerup_weapon
            }
        }
    }

    const WaveSystem = {
        waveNumber: 0,
        timer: 0,
        betweenWaves: true,
        waveDelay: 3000,
        
        init() {
            this.waveNumber = 0;
            this.betweenWaves = true;
            this.timer = this.waveDelay;
        },

        update(deltaTime) {
            if (this.betweenWaves) {
                this.timer -= deltaTime;
                if (this.timer <= 0) {
                    this.nextWave();
                }
            } else {
                if (enemies.length === 0 && !boss) {
                    this.betweenWaves = true;
                    this.timer = this.waveDelay;
                }
            }
        },

        nextWave() {
            this.waveNumber++;
            this.betweenWaves = false;
            this.announceWave();

            if (this.waveNumber % 5 === 0) { // Boss wave
                this.spawnBoss();
                return;
            }

            const waveConfig = this.getWaveConfig();
            for (const type in waveConfig) {
                for (let i = 0; i < waveConfig[type]; i++) {
                    this.spawnEnemy(type);
                }
            }
        },

        spawnEnemy(type) {
            let x, y;
            if (Math.random() < 0.5) {
                x = Math.random() < 0.5 ? -30 : canvas.width + 30;
                y = Math.random() * canvas.height;
            } else {
                x = Math.random() * canvas.width;
                y = Math.random() < 0.5 ? -30 : canvas.height + 30;
            }

            switch(type) {
                case 'striker':
                    enemies.push(new Enemy({x, y, radius: 15, speed: 2.5, health: 50, color: '#e056fd', scoreValue: 20, type}));
                    break;
                case 'gunner':
                    enemies.push(new GunnerEnemy({x, y}));
                    break;
                case 'brute':
                    enemies.push(new Enemy({x, y, radius: 30, speed: 1, health: 200, color: '#c23616', scoreValue: 100, type}));
                    break;
            }
        },
        
        spawnBoss() {
            boss = new Boss();
        },

        getWaveConfig() {
            const w = this.waveNumber;
            return {
                striker: 2 + w * 2,
                gunner: w > 1 ? 1 + Math.floor(w/2) : 0,
                brute: w > 3 ? Math.floor(w/3) : 0,
            };
        },

        announceWave() {
            const message = this.waveNumber % 5 === 0 ? "!!! BOSS WAVE !!!" : `WAVE ${this.waveNumber}`;
            waveAnnouncer.textContent = message;
            waveAnnouncer.style.opacity = 1;
            setTimeout(() => { waveAnnouncer.style.opacity = 0; }, 2000);
        }
    };
    
    class Boss extends Entity {
        constructor() {
            super({
                x: canvas.width / 2, y: -100,
                radius: 80, speed: 2
            });
            this.maxHealth = 5000 + WaveSystem.waveNumber * 500;
            this.health = this.maxHealth;
            this.collisionDamage = 50;
            this.hitTimer = 0;
            this.state = 'entering'; // entering, shooting, charging
            this.stateTimer = 0;
            this.patterns = [this.shootSpiral.bind(this), this.shootVolley.bind(this)];
            this.currentPattern = 0;
        }

        update(deltaTime) {
            this.stateTimer -= deltaTime;
            if (this.hitTimer > 0) this.hitTimer -= deltaTime;

            switch(this.state) {
                case 'entering':
                    this.y += this.speed;
                    if (this.y >= 150) {
                        this.y = 150;
                        this.state = 'shooting';
                        this.stateTimer = 5000;
                    }
                    break;
                case 'shooting':
                    this.patterns[this.currentPattern](deltaTime);
                    if (this.stateTimer <= 0) {
                        this.state = 'charging';
                        this.chargeTarget = {x: player.x, y: player.y};
                        this.stateTimer = 2000;
                    }
                    break;
                case 'charging':
                    const dx = this.chargeTarget.x - this.x;
                    const dy = this.chargeTarget.y - this.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if(dist > 20) {
                       this.x += dx/dist * this.speed * 3;
                       this.y += dy/dist * this.speed * 3;
                    } else {
                        this.state = 'shooting';
                        this.stateTimer = 5000;
                        this.currentPattern = (this.currentPattern + 1) % this.patterns.length;
                    }
                    break;
            }
        }
        
        takeDamage(amount) {
            this.health -= amount;
            this.hitTimer = 100;
            if (this.health <= 0) this.die();
        }

        die() {
            score += 5000;
            boss = null;
            createExplosion(this.x, this.y, this.radius * 3, 200);
            triggerScreenShake(50, 1500);
            // Sonido: boss_die
        }
        
        draw() {
            // Main body
            const color = this.hitTimer > 0 ? 'white' : '#8e44ad';
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();

            // Health bar
            const barWidth = this.radius * 2;
            ctx.fillStyle = '#555';
            ctx.fillRect(this.x - this.radius, this.y - this.radius - 20, barWidth, 15);
            ctx.fillStyle = '#ff4757';
            ctx.fillRect(this.x - this.radius, this.y - this.radius - 20, barWidth * (this.health / this.maxHealth), 15);
        }

        // --- Attack Patterns ---
        shootSpiral(deltaTime) {
            this.lastShot = (this.lastShot || 0) + deltaTime;
            if (this.lastShot > 50) {
                this.lastShot = 0;
                this.shotAngle = (this.shotAngle || 0) + 0.3;
                enemyBullets.push(new EnemyBullet({
                    x: this.x, y: this.y,
                    direction: {x: Math.cos(this.shotAngle), y: Math.sin(this.shotAngle)}
                }));
            }
        }
        
        shootVolley(deltaTime) {
            this.lastShot = (this.lastShot || 0) + deltaTime;
            if (this.lastShot > 800) {
                this.lastShot = 0;
                const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x);
                for(let i = -2; i <= 2; i++) {
                     enemyBullets.push(new EnemyBullet({
                        x: this.x, y: this.y,
                        direction: {x: Math.cos(angleToPlayer + i*0.2), y: Math.sin(angleToPlayer + i*0.2)}
                    }));
                }
            }
        }
    }

    </script>
</body>
</html>
